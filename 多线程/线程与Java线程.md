# 线程
### 线程的基本结构
 在现代多线程的环境下，线程作为CPU的执行单元 ，需要为自己的正常执行准备一系列条件。这包括 程序计数器，寄存器组，线程ID,内存区域。线程占有的内存区域大致划分为堆，栈 以及与同一进程内其他线程共享的代码段和数据段，和其他操作系统的一些资源。
 
~~这里的线程指的是操作系统的内核线程？~~
### 多线程模型
  
  什么是多线程模型呢？简单来说就是用户创建的进程包含多个线程的话，那么这些线程是如何被执行的问题。在进程管理里面忘记了说一点，就是操作系统为了确保操作系统能够正常进行，就必须区分开哪一部分代码是属于操作系统的，哪一部分不是。如何保证这一点呢？计算机在硬件上通过提供一个模式位来支持这一点。当执行操作系统的服务时，系统就处于特权模式；当执行用户任务时，系统就处于用户模式。从而限制了用户程序对磁盘某些存储区域的访问。
  
  #### 话外
  从Abraham的操作系统一书中 完全抄袭过来的
  
  
  当系统引导时，硬件从内核模式开始。操作系统接着加载，加载到用户程序时，切换到用户模式，当加载用户程序执行到某一步骤发生了中断或者陷阱，硬件就会将用户模式切换为特权模式。循环往复。
  
  
  #### 话外结束
  
   线程可分为用户线程和内核线程。其中用户线程运行于操作系统的内核之上，因此用户级别的线程不需要内核直接支持。内核线程则由操作系统直接管理和支持。但是用户级别的线程如何运行呢？就必须要映射到内核线程，通过系统调用或者中断与内核线程进行交互。
  
  - 多个用户线程 对应一个内核线程。 缺点是当一个用户线程发出系统调用阻塞时，其他用户线程也需要等待
  - 一个用户线程对应一个内核线程。
  - 多个用户线程对应多个内核进程。
  
  
  上述三类便是多线程的模型了。交互原理会继续传播。
### 线程库 
   万事不用从头来，复用的思想自古有之。线程库就是为程序员提供的创建和管理线程的API。这样就不用去手动实现如何创建和管理线程了。线程库的实现方式，大体上分为两种：一种是在用户空间提供一个没有内核支持的代码库，另一种方式是有操作系统内核提供一个线程库。
   
   
   前者就像是我们写的可以复用的组件，调用是本地调用，调用库时不会与内核交互。
   
   
   后者是也是复用了组件，但为系统调用，也就是说会中断，从而将执行权从用户转移到内核。
   
   
### 内核线程与用户线程的交互

  前面提到了多线程模型，这一部分就来传播下多线程模型交互的一些原理。
  
  
  交互是什么？交互就是聊天，我给大家说几句话，大家给我点回应；我给一个人说几句话，那个人给我个回应；我给大家说几句话，知道的人给我会句话。总的来说，就是我用说话的方式释放了一个信号，然后在不同的场景下，得到了不同的回应。线程之间的交互本质上也是如此，但是需要我们做一点东西。
  
  
  内核线程和用户线程之间也是通过信号交互的，信号是怎么产生的呢，计算机里面的信号都是事件产生的，怎么产生事件呢，通过中断。内核线程通过中断告诉用户线程，用户线程通过中断告知内核线程。接受到中断信号后，对方就会做相应的处理，很守约。但是这双方之间的交互，有时会多一个代理。但总的交互原理是不变的。改变的是 **管理交互** 的原理，这个代理称作LWP,Light Weight Progress 翻译为中文 虚拟处理器 。
  
  
  比方说A进程里面有a1,a2,a3 三个用户线程 ；内核进程里面有 c1,c2 两个内核线程 ；有两个LWP p1,p2;
  
  
  这时候 A要执行，就会问LWP,您有空闲么？ LWP 一看，自己的p2 没有在执行中，就会告知 A 有空闲。
 
 
  然后 A 里面的a1,a2,a3 就开始抢占 p2。先到先得。假如a3 抢到了。
  
  
  这时候，与p2 关联的内核线程 p1 ，就开始执行 a3 的任务 。
  
  
  执行到了一半，被定时器告知，这个p2 的时间片用完了。就会告知p2 ,你要准备下一个任务了。然后 c2 就做一些善后工作 等待下一次被调用。
 
 
 


### JAVA线程
